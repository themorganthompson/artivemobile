"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _fs = _interopRequireDefault(require("fs"));

var _path = _interopRequireDefault(require("path"));

var _json = _interopRequireDefault(require("json5"));

var _findCacheDir = _interopRequireDefault(require("find-cache-dir"));

var _server = require("@storybook/core/server");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// avoid ESLint errors
const logger = console;

function removeReactHmre(presets) {
  const index = presets.indexOf('react-hmre');

  if (index > -1) {
    presets.splice(index, 1);
  }
} // Tries to load a .babelrc and returns the parsed object if successful


function loadBabelConfig(babelConfigPath) {
  let config;

  if (_fs.default.existsSync(babelConfigPath)) {
    const content = _fs.default.readFileSync(babelConfigPath, 'utf-8');

    try {
      config = _json.default.parse(content);
      config.babelrc = false;
    } catch (e) {
      logger.error(`=> Error parsing .babelrc file: ${e.message}`);
      throw e;
    }
  }

  if (!config) return null; // Remove react-hmre preset.
  // It causes issues with react-storybook.
  // We don't really need it.
  // Earlier, we fix this by runnign storybook in the production mode.
  // But, that hide some useful debug messages.

  if (config.presets) {
    removeReactHmre(config.presets);
  }

  if (config.env && config.env.development && config.env.development.presets) {
    removeReactHmre(config.env.development.presets);
  }

  return config;
} // `baseConfig` is a webpack configuration bundled with storybook.
// Storybook will look in the `configDir` directory
// (inside working directory) if a config path is not provided.


function _default(configType, baseConfig, projectDir, configDir) {
  const config = baseConfig; // Search for a .babelrc in project directory, config directory, and storybook
  // module directory. If found, use that to extend webpack configurations.

  const babelConfigInConfig = loadBabelConfig(_path.default.resolve(configDir, '.babelrc'));
  const babelConfigInProject = loadBabelConfig(_path.default.resolve(projectDir, '.babelrc'));
  const babelConfigInModule = loadBabelConfig('.babelrc');
  let babelConfig = null;
  let babelConfigDir = '';

  if (babelConfigInConfig) {
    logger.info('=> Loading custom .babelrc from config directory.');
    babelConfig = babelConfigInConfig;
    babelConfigDir = configDir;
  } else if (babelConfigInProject) {
    logger.info('=> Loading custom .babelrc from project directory.');
    babelConfig = babelConfigInProject;
    babelConfigDir = projectDir;
  } else {
    babelConfig = babelConfigInModule;
  }

  if (babelConfig) {
    // If the custom config uses babel's `extends` clause, then replace it with
    // an absolute path. `extends` will not work unless we do this.
    if (babelConfig.extends) {
      babelConfig.extends = babelConfigDir ? _path.default.resolve(babelConfigDir, babelConfig.extends) : _path.default.resolve(babelConfig.extends);
    }

    config.module.rules[0].query = babelConfig;
  } // This is a feature of `babel-loader` for webpack (not Babel itself).
  // It enables a cache directory for faster-rebuilds
  // `find-cache-dir` will create the cache directory under the node_modules directory.


  config.module.rules[0].query.cacheDirectory = (0, _findCacheDir.default)({
    name: 'react-storybook'
  }); // Check whether addons.js file exists inside the storybook.

  const storybookCustomAddonsPath = _path.default.resolve(configDir, 'addons.js');

  if (_fs.default.existsSync(storybookCustomAddonsPath)) {
    logger.info('=> Loading custom addons config.');
    config.entry.manager.unshift(storybookCustomAddonsPath);
  }

  const defaultConfig = (0, _server.createDefaultWebpackConfig)(config); // Check whether user has a custom webpack config file and
  // return the (extended) base configuration if it's not available.

  const customConfigPath = _path.default.resolve(configDir, 'webpack.config.js');

  if (!_fs.default.existsSync(customConfigPath)) {
    logger.info('=> Using default webpack setup based on "Create React App".');
    return defaultConfig;
  }

  const customConfig = require(customConfigPath); // eslint-disable-line


  if (typeof customConfig === 'function') {
    logger.info('=> Loading custom webpack config (full-control mode).');
    return customConfig(config, configType, defaultConfig, configDir);
  }

  logger.info('=> Loading custom webpack config.');
  customConfig.module = customConfig.module || {};
  return _objectSpread({}, customConfig, config, {
    // We need to use our and custom plugins.
    plugins: [...config.plugins, ...(customConfig.plugins || [])],
    module: _objectSpread({}, config.module, customConfig.module, {
      rules: [...config.module.rules, ...(customConfig.module.rules || [])]
    })
  });
}